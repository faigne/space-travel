import{M as e,C as t,S as n,T as a,V as o,a as r,b as i,c as s,D as c,A as l,B as p,d as h,e as m,f,g as u,h as v,O as d,G as x,i as g,j as y,P as R,W as w}from"https://webgl-space-travel.netlify.app/assets/vendor.53d8c99e.js";!function(e=".",t="__import__"){try{self[t]=new Function("u","return import(u)")}catch(n){const a=new URL(e,location),o=e=>{URL.revokeObjectURL(e.src),e.remove()};self[t]=e=>new Promise(((n,r)=>{const i=new URL(e,a);if(self[t].moduleMap[i])return n(self[t].moduleMap[i]);const s=new Blob([`import * as m from '${i}';`,`${t}.moduleMap['${i}']=m;`],{type:"text/javascript"}),c=Object.assign(document.createElement("script"),{type:"module",src:URL.createObjectURL(s),onerror(){r(new Error(`Failed to import: ${e}`)),o(c)},onload(){n(self[t].moduleMap[i]),o(c)}});document.head.appendChild(c)})),self[t].moduleMap={}}}("/assets/");class S{constructor(e){this.paused=!0,this.requestId=0,this.onRender=()=>{e(),this.requestNextRender()}}start(){this.paused&&(this.paused=!1,this.requestNextRender())}pause(){this.paused||(this.paused=!0,this.cancelNextRender())}cancelNextRender(){this.requestId&&window.cancelAnimationFrame(this.requestId)}requestNextRender(){this.requestId=window.requestAnimationFrame(this.onRender)}}const M=()=>e.seededRandom(),b=(t,n,a,o)=>{const r=e.lerp(t,n,a);return Math.abs(n-r)<o?n:r};class O{constructor(e={}){const{throttle:n=0,throttleLerpFactor:a=.035,opacity:o=1,opacityLerpFactor:r=.016,startOpacity:i=0}=e;this.clock=new t(!1),this.delta=0,this.throttle=n,this.throttleTarget=n,this.throttleLerpFactor=a,this.opacity=i,this.opacityTarget=o,this.opacityLerpFactor=r,this.update()}get isPaused(){return!this.clock.running}update(){this.delta=this.clock.getDelta(),this.throttle!==this.throttleTarget&&(this.throttle=b(this.throttle,this.throttleTarget,this.throttleLerpFactor,.01)),this.opacity!==this.opacityTarget&&(this.opacity=b(this.opacity,this.opacityTarget,this.opacityLerpFactor,.01))}start(){this.clock.start()}pause(){this.clock.stop()}setThrottle(e){this.throttleTarget=e}setOpacity(e){this.opacityTarget=e}}class F extends n{constructor(e,t={}){const{container:{length:n,depth:h}={length:40,depth:40},colorRange:{min:m,max:f}={min:3172607,max:15945620},thicknessRange:{min:u,max:v}={min:.035,max:.06},rayLengthRange:{min:d,max:x}={min:.1,max:2.5},stretchFactorRange:{min:g,max:y}={min:0,max:1.5},shakeSpeedFactor:R=.001,shakeStrengthFactor:w=.0035,speedRange:S={min:.5,max:60},particleTextureUrl:M="https://webgl-space-travel.netlify.app/particle-sprite.png",noiseTextureUrl:b="https://webgl-space-travel.netlify.app/noise.jpg"}=t,O=new a,F=O.load(M),k=O.load(b);k.wrapT=1e3,k.wrapS=1e3;const L=new p(new r(-n/2,-n/2,-h/2),new r(n/2,n/2,h/2));super({vertexShader:"\nattribute float corner;\nattribute float colorMix;\n\nvarying vec2 vUv;\nvarying vec3 vColor;\n\nuniform float globalOpacity;\nuniform sampler2D noise;\nuniform vec3 bboxMax;\nuniform vec3 bboxMin;\nuniform vec2 offset;\nuniform vec3 direction;\nuniform mat4 rotation;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform float minThickness;\nuniform float maxThickness;\nuniform float minRayLength;\nuniform float maxRayLength;\nuniform float minStretchFactor;\nuniform float maxStretchFactor;\nuniform float shakeSpeedFactor;\nuniform float shakeStrengthFactor;\nuniform float throttle;\nuniform float distance;\n\nfloat remap(float value, float inMin, float inMax, float outMin, float outMax) {\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n}\n\nvec2 rotate(vec2 v, float a) {\n  float s = sin(a);\n  float c = cos(a);\n  mat2 m = mat2(c, -s, s, c);\n  return m * v;\n}\n\n\nvoid main() {\n  vUv = uv;\n\n  // set particle color based on mix attribute\n  vColor = mix(color1, color2, colorMix);\n\n  float zRange = bboxMax.z - bboxMin.z;\n  float yRange = bboxMax.y - bboxMin.y;\n  float xRange = bboxMax.x - bboxMin.x;\n\n  vec3 pos = position;\n  pos += (distance * vec3(0.0, 0.0, 1.0));\n  pos.x -= offset.x;\n  pos.x = mod(pos.x, xRange) - xRange / 2.0;\n  pos.y -= offset.y;\n  pos.y = mod(pos.y, yRange) - (yRange / 2.0);\n  pos.z = mod(pos.z, zRange) - zRange / 2.0;\n\n  vec4 worldPos = modelMatrix * vec4(pos, 1.0);\n  vec4 worldOrigin = worldPos;\n  vec4 pOrigin = projectionMatrix * viewMatrix * worldOrigin;\n\n  float globalSizeFactor = clamp(remap(pOrigin.z, zRange, zRange * 0.925, 0.0, globalOpacity), 0.0, globalOpacity);\n  float rayLength = remap(throttle, 0.0, 1.0, minRayLength, maxRayLength);\n  float stretchFactor = remap(throttle, 0.0, 1.0, minStretchFactor, maxStretchFactor);\n\n  if (corner == 3.0 || corner == 1.0) {\n    worldPos.xyz -= (direction * rayLength * stretchFactor * globalSizeFactor);\n  }\n\n  if (corner == 0.0 || corner == 2.0) {\n    worldPos.xyz += (direction * rayLength * stretchFactor * globalSizeFactor);\n  }\n\n  vec4 viewPosition = viewMatrix * worldPos;\n  viewPosition = rotation * vec4(viewPosition.xyz, 1.0);\n\n  float size =  0.1 * globalSizeFactor;\n  float thickness = remap(throttle, 0.0, 1.0, minThickness, maxThickness);\n  float verticalStretch = mix(size, thickness, stretchFactor);\n  float angle = atan(-worldOrigin.y, -worldOrigin.x);\n\n  if (corner == 0.0) {\n    viewPosition.xy += rotate(vec2(-size, -verticalStretch), angle);\n  }\n\n  if (corner == 1.0) {\n    viewPosition.xy += rotate(vec2(size, -verticalStretch), angle);\n  }\n\n  if (corner == 2.0) {\n    viewPosition.xy += rotate(vec2(-size, verticalStretch), angle);\n  }\n\n  if (corner == 3.0) {\n    viewPosition.xy += rotate(vec2(size, verticalStretch), angle);\n  }\n\n  // Camera Shake\n  float shakeSpeed = shakeSpeedFactor * throttle;\n  float offsetX = remap(texture2D(noise, vec2(distance * shakeSpeed, 0)).r, 0.0, 1.0, -1.0, 1.0);\n  float offsetY = remap(texture2D(noise, vec2(distance * shakeSpeed, 0.5)).r, 0.0, 1.0, -1.0, 1.0);\n  float shakeStrength = shakeStrengthFactor * throttle;\n  vec2 shakeOffset = vec2(offsetX, offsetY) * shakeStrength;\n\n  vec4 pPosition = projectionMatrix * viewPosition;\n  pPosition.xy /= pPosition.w;\n  pPosition.xy += shakeOffset;\n  pPosition.xy *= pPosition.w;\n\n  gl_Position = pPosition;\n}\n",fragmentShader:"\nvarying vec2 vUv;\nvarying vec3 vColor;\n\nuniform sampler2D map;\n\nvoid main() {\n  vec4 texel = texture2D(map, vUv);\n  float alpha = texel.r;\n  vec3 color = mix(vColor, vec3(1.0), texel.r);\n\n  gl_FragColor = vec4(color, alpha);\n}\n",uniforms:{globalOpacity:{value:1},map:{value:F},noise:{value:k},bboxMin:{value:L.min},bboxMax:{value:L.max},offset:{value:new o(0,0)},direction:{value:new r(0,0,1)},rotation:{value:new i},color1:{value:new s(m)},color2:{value:new s(f)},minThickness:{value:u},maxThickness:{value:v},minRayLength:{value:d},maxRayLength:{value:x},minStretchFactor:{value:g},maxStretchFactor:{value:y},shakeSpeedFactor:{value:R},shakeStrengthFactor:{value:w},throttle:{value:0},distance:{value:0}}}),this.context=e,this.speedRange=S,this.depthWrite=!1,this.transparent=!0,this.side=c,this.blending=l}update(){const{delta:t,throttle:n,opacity:a}=this.context;this.uniforms.throttle.value=n,this.uniforms.globalOpacity.value=a;const o=e.mapLinear(n,0,1,this.speedRange.min,this.speedRange.max);this.uniforms.distance.value+=t*o}}class k extends h{constructor(t,n={}){const{count:a=1500,container:{length:o,depth:r}={length:40,depth:40},container:i,colorRange:s,thicknessRange:c,rayLengthRange:l,speedRange:p,stretchFactorRange:h,shakeSpeedFactor:u,shakeStrengthFactor:v}=n,d=((t,n,a)=>{const o=[],r=[],i=[],s=[],c=[],l=new m;for(let p=0;p<t;p++){const t=e.mapLinear(M(),0,1,-n/2,n/2),l=e.mapLinear(M(),0,1,-n/2,n/2),h=e.mapLinear(M(),0,1,-a/2,a/2);o.push(t,l,h,t,l,h,t,l,h,t,l,h),i.push(0,1,1,1,0,0,1,0),r.push(0,1,2,3);const m=M();c.push(m,m,m,m);const f=4*p;s.push(f,f+1,f+2,f+1,f+3,f+2)}return l.setAttribute("position",new f(new Float32Array(o),3)),l.setAttribute("uv",new f(new Float32Array(i),2)),l.setAttribute("corner",new f(new Float32Array(r),1)),l.setAttribute("colorMix",new f(new Float32Array(c),1)),l.setIndex(s),l})(a,o,r),x=new F(t,{container:i,colorRange:s,thicknessRange:c,rayLengthRange:l,speedRange:p,stretchFactorRange:h,shakeSpeedFactor:u,shakeStrengthFactor:v});super(d,x),this.frustumCulled=!1,this.position.z-=r/2,this.onBeforeRender=()=>{x.update()}}}const L=new a,P=e=>{if(!e)return new v;const t=L.load(e);return t.wrapS=1e3,t.wrapT=1e3,t};class z extends n{constructor(e,t){const{textureUrl:n="",colorRange:{min:a,max:o}={min:16711680,max:255},repeatOffsetRange:{min:r,max:c}={min:[1,1],max:[.15,1]},opacityRange:{min:l,max:p}={min:.5,max:1},fallOffDistance:h=-8,speedRange:m={min:.0025,max:.5},rotationSpeedRange:f={min:1,max:45}}=t;super({vertexShader:"\nvarying vec2 vUvSample1;\nvarying vec2 vUvSample2;\nvarying vec2 vUvSample3;\nvarying vec3 vViewPosition;\n\nuniform float throttle;\nuniform vec4 offsetRepeatMin;\nuniform vec4 offsetRepeatMax;\nuniform float distance;\nuniform float rotationDistance;\nuniform mat4 rotation;\n\nvec2 transformUV(in vec2 uv, in float t, in vec2 offset, in vec2 scale) {\n  vec2 result = vec2(uv.x, uv.y);\n  result *= scale;\n  result += (offset * t);\n  return result;\n}\n\nvec2 rotate(vec2 v, float a) {\n  float s = sin(a);\n  float c = cos(a);\n  mat2 m = mat2(c, -s, s, c);\n  return m * v;\n}\n\nvoid main() {\n  vec4 offsetRepeat = mix(offsetRepeatMin, offsetRepeatMax, throttle);\n\n  vec2 uvOffset1 = offsetRepeat.xy * vec2(1.0, 1.0);\n  vec2 uvOffset2 = offsetRepeat.xy * vec2(1.0, 1.0);\n  vec2 uvOffset3 = offsetRepeat.xy * vec2(1.0, 1.0);\n\n  vec2 uvScale1 = offsetRepeat.zw * vec2(1.0, 1.0);\n  vec2 uvScale2 = offsetRepeat.zw * vec2(0.5, 1.0);\n  vec2 uvScale3 = offsetRepeat.zw * vec2(2.0, 1.0);\n\n  vUvSample1 = transformUV(uv, distance * 2.0, uvOffset1, uvScale1);\n  vUvSample2 = transformUV(uv, distance * 0.5, uvOffset2, uvScale2);\n  vUvSample3 = transformUV(uv, distance * 8.0, uvOffset3, uvScale3);\n\n  vec3 viewPosition = (modelViewMatrix * vec4(position, 1.0)).xyz;\n\n  viewPosition.xy = rotate(viewPosition.xy, rotationDistance);\n\n  viewPosition = (rotation * vec4(viewPosition, 1.0)).xyz;\n\n  vViewPosition = viewPosition;\n\n  gl_Position = projectionMatrix * vec4(viewPosition, 1.0);\n}\n",fragmentShader:"\nvarying vec2 vUvSample1;\nvarying vec2 vUvSample2;\nvarying vec2 vUvSample3;\nvarying vec3 vViewPosition;\n\nuniform float throttle;\nuniform vec3 colorMin;\nuniform vec3 colorMax;\nuniform float opacityMin;\nuniform float opacityMax;\nuniform float globalOpacity;\nuniform sampler2D map;\nuniform float fallOffDistance;\n\nfloat remap(float value, float inMin, float inMax, float outMin, float outMax) {\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n}\n\nfloat linearTosRGB(const in float c) {\n  if (c >= 1.0) return 1.0;\n  float S1 = sqrt(c);\n  float S2 = sqrt(S1);\n  float S3 = sqrt(S2);\n  return 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * c;\n}\n\nvoid main() {\n  vec3 color = mix(colorMin, colorMax, throttle);\n  float opacity = mix(opacityMin, opacityMax, throttle) * globalOpacity;\n  vec4 outputColor = vec4(color, opacity);\n\n  vec4 sample1 = texture2D(map, vUvSample1);\n  vec4 sample2 = texture2D(map, vUvSample2);\n  vec4 sample3 = texture2D(map, vUvSample3);\n\n  float alpha = sample1.r * sample2.r * sample3.r * 4.0;\n\n  float falloff = clamp(remap(vViewPosition.z, 0.0, fallOffDistance, 1.0, 0.0), 0.0, 1.0);\n\n  outputColor.a *= alpha;\n\n  outputColor.a = linearTosRGB(outputColor.a);\n\n  outputColor.a *= falloff;\n\n  gl_FragColor = outputColor;\n}\n",uniforms:{globalOpacity:{value:1},map:{value:P(n)},colorMin:{value:new s(a)},colorMax:{value:new s(o)},opacityMin:{value:l},opacityMax:{value:p},offsetRepeatMin:{value:new u(1,0,...r)},offsetRepeatMax:{value:new u(1,0,...c)},fallOffDistance:{value:h},rotation:{value:new i},throttle:{value:0},distance:{value:0},rotationDistance:{value:0}}}),this.context=e,this.speedRange=m,this.rotationSpeedRange=f,this.transparent=!0,this.depthWrite=!1}update(){const{delta:t,throttle:n,opacity:a}=this.context;this.uniforms.throttle.value=n,this.uniforms.globalOpacity.value=a;const o=e.mapLinear(n,0,1,this.speedRange.min,this.speedRange.max);this.uniforms.distance.value+=t*o;const r=e.mapLinear(n,0,1,this.rotationSpeedRange.min,this.rotationSpeedRange.max);this.uniforms.rotationDistance.value+=e.degToRad(t*r)}}class U extends d{constructor(e,t){super(),this.createConeModel(e,t)}async createConeModel(e,t={}){const{coneModelUrl:n="https://webgl-space-travel.netlify.app/cone.glb",textureUrl:a,colorRange:o,opacityRange:r,repeatOffsetRange:i,fallOffDistance:s,speedRange:c,rotationSpeedRange:l}=t,{scene:{children:[p]}}=await(new x).loadAsync(n),h=p,m=new z(e,{textureUrl:a,colorRange:o,opacityRange:r,repeatOffsetRange:i,fallOffDistance:s,speedRange:c,rotationSpeedRange:l});h.material=m,h.scale.set(2,1,2),h.position.z-=5,h.rotation.z=-Math.PI,h.onBeforeRender=()=>{m.update()},this.add(h)}}const C=[{textureUrl:"https://webgl-space-travel.netlify.app/clouds1.jpg",colorRange:{min:16711746,max:16711746},opacityRange:{min:.05,max:.2},speedRange:{min:.0025,max:.175},repeatOffsetRange:{min:[1,1],max:[.33,1]},fallOffDistance:-8,rotationSpeedRange:{min:1,max:30}},{textureUrl:"https://webgl-space-travel.netlify.app/noise3.jpg",colorRange:{min:2513405,max:2513405},opacityRange:{min:.05,max:.25},speedRange:{min:.003,max:.075},repeatOffsetRange:{min:[.5,1],max:[.25,1]},fallOffDistance:-6,rotationSpeedRange:{min:.5,max:25}},{textureUrl:"https://webgl-space-travel.netlify.app/noise3.jpg",colorRange:{min:8716527,max:8716527},opacityRange:{min:.02,max:.25},speedRange:{min:.002,max:.1125},repeatOffsetRange:{min:[.75,1],max:[.35,1]},fallOffDistance:-6,rotationSpeedRange:{min:1.09,max:31}}];class T extends g{constructor(e,t=C){super();for(const n of t){const t=new U(e,n);this.add(t)}}}class D extends y{constructor(e,t={}){super();const{backgroundColor:n=524303,starfield:a,nebulae:o}=t,r=new k(e,a),i=new T(e,o);this.camera=this.createCamera(),this.add(this.camera),this.setObjectRenderOrder(i,0),this.setObjectRenderOrder(r,1),this.camera.add(i),this.camera.add(r),this.frustumCulled=!1,this.background=new s(n)}render(e){e.render(this,this.camera)}setCameraAspectRatio(e){this.camera.aspect=e,this.camera.updateProjectionMatrix()}createCamera(){const e=new R(60,1,.01,500);return e.position.set(0,0,-4),e.lookAt(new r(0,0,0)),e}setObjectRenderOrder(e,t){e.traverse((e=>{e.renderOrder=t}))}}const j=document.querySelector("#space-travel");if(!j)throw new Error("Canvas not found");let A=!1,q=0;const V=new class{constructor(e){const{canvas:t,backgroundColor:n,throttle:a,throttleLerpFactor:o,opacity:r,startOpacity:i,opacityLerpFactor:s,starfield:c,nebulae:l}=e;if(!(t instanceof HTMLCanvasElement))throw new TypeError("Invalid canvas");this.context=new O({throttle:a,throttleLerpFactor:o,opacity:r,startOpacity:i,opacityLerpFactor:s}),this.scene=new D(this.context,{backgroundColor:n,starfield:c,nebulae:l}),this.renderer=this.createRenderer(t),this.setSize(t),this.renderLoop=new S(this.onRender.bind(this))}get throttle(){return this.context.throttleTarget}set throttle(e){this.context.setThrottle(e)}get opacity(){return this.context.opacityTarget}set opacity(e){this.context.setOpacity(e)}start(){this.context.start(),this.renderLoop.start()}resume(){this.start()}pause(){this.context.pause(),this.renderLoop.pause()}resize(){this.setSize(this.renderer.domElement)}createRenderer(e){const t=new w({canvas:e}),n=Math.min(window.devicePixelRatio,1.5);return t.setPixelRatio(n),t}setSize(e){const t=e.offsetWidth,n=e.offsetHeight;this.renderer.setSize(t,n,!1),this.scene.setCameraAspectRatio(t/n)}isRenderable(){const{opacity:e}=this.context;return 0!==e}onRender(){this.context.update(),this.isRenderable()&&this.scene.render(this.renderer)}}({canvas:j,throttle:q});document.addEventListener("visibilitychange",(()=>{A||(document.hidden?V.pause():V.resume())})),document.addEventListener("keydown",(({code:e})=>{"Space"===e&&(A?V.resume():V.pause(),A=!A),"ArrowDown"===e&&(q=Math.max(0,q-.2),V.throttle=q),"ArrowUp"===e&&(q=Math.min(1,q+.2),V.throttle=q)})),window.addEventListener("resize",(()=>{V.resize()})),V.start();